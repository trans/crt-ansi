module CRT::Ansi
  module DisplayWidth
    extend self

    ZERO_WIDTH_JOINER     = 0x200D
    ZERO_WIDTH_NON_JOINER = 0x200C

    # Width tables parsed from data/widths.txt at compile time.
    # The file is generated by scripts/generate_width_tables.cr from
    # Unicode consortium EastAsianWidth.txt and emoji-data.txt.
    TABLES = begin
      tables = {
        "COMBINING"   => [] of {Int32, Int32},
        "DOUBLEWIDTH" => [] of {Int32, Int32},
        "AMBIGUOUS"   => [] of {Int32, Int32},
        "NARROW"      => [] of {Int32, Int32},
        "EMOJI"       => [] of {Int32, Int32},
      }

      current = nil
      {{ read_file("#{__DIR__}/data/widths.txt") }}.each_line do |line|
        line = line.strip
        next if line.empty? || line.starts_with?('#')

        if tables.has_key?(line)
          current = tables[line]
        elsif target = current
          parts = line.split
          if parts.size == 2
            target << {parts[0].to_i(16), parts[1].to_i(16)}
          end
        end
      end

      tables
    end

    # Returns the display width of the first `grapheme_index` graphemes.
    def width_to(text : String, grapheme_index : Int32) : Int32
      col = 0
      i = 0
      Graphemes.each(text) do |g|
        break if i >= grapheme_index
        col += of(g)
        i += 1
      end
      col
    end

    # Returns the grapheme index at or before the given absolute display column.
    def grapheme_at_column(text : String, column : Int32) : Int32
      col = 0
      gi = 0
      Graphemes.each(text) do |g|
        gw = of(g)
        if col + gw > column
          return gi
        end
        col += gw
        gi += 1
      end
      gi
    end

    # Returns the display width of a string by summing grapheme cluster widths.
    def width(text : String) : Int32
      total = 0
      Graphemes.each(text) { |g| total += of(g) }
      total
    end

    # Returns the display width of a single grapheme cluster.
    def of(grapheme : String) : Int32
      return 1 if grapheme.empty?

      width = 0
      has_visible_codepoint = false

      grapheme.each_char do |char|
        ord = char.ord
        next if zero_width?(char, ord)

        has_visible_codepoint = true
        candidate = in_table?(ord, TABLES["DOUBLEWIDTH"]) ? 2 : 1
        width = candidate if candidate > width
      end

      if !has_visible_codepoint
        return 2 if grapheme.includes?('\u{200D}') || grapheme.includes?('\u{FE0F}')
        return 1
      end

      # VS16 (emoji presentation selector) promotes emoji-capable codepoints to width 2
      if width < 2 && grapheme.includes?('\u{FE0F}')
        grapheme.each_char do |char|
          if in_table?(char.ord, TABLES["EMOJI"])
            width = 2
            break
          end
        end
      end

      width
    end

    private def zero_width?(char : Char, ord : Int32) : Bool
      char.mark? ||
        ord == ZERO_WIDTH_JOINER ||
        ord == ZERO_WIDTH_NON_JOINER ||
        variation_selector?(ord) ||
        control_codepoint?(ord)
    end

    private def control_codepoint?(ord : Int32) : Bool
      (0x00..0x1F).includes?(ord) || (0x7F..0x9F).includes?(ord)
    end

    private def variation_selector?(ord : Int32) : Bool
      (0xFE00..0xFE0F).includes?(ord) || (0xE0100..0xE01EF).includes?(ord)
    end

    # Binary search over a sorted table of {low, high} ranges.
    protected def in_table?(ord : Int32, table : Array({Int32, Int32})) : Bool
      return false if table.empty? || ord < table[0][0]
      lo = 0
      hi = table.size - 1
      while lo <= hi
        mid = (lo + hi) >> 1
        if table[mid][1] < ord
          lo = mid + 1
        elsif table[mid][0] > ord
          hi = mid - 1
        else
          return true
        end
      end
      false
    end
  end
end
